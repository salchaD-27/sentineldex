# Minimal core entity - created immediately with no eth_calls
type TokenCore @entity(immutable: false) {
  id: ID!
  address: Bytes!
}

# Individual metadata entities - each fetched separately with one eth_call
type TokenSymbol @entity(immutable: false) {
  id: ID!           # token_address + "-symbol"
  token: TokenCore!
  value: String!
}

type TokenName @entity(immutable: false) {
  id: ID!           # token_address + "-name"
  token: TokenCore!
  value: String!
}

type TokenDecimals @entity(immutable: false) {
  id: ID!           # token_address + "-decimals"
  token: TokenCore!
  value: BigInt!
}

type TokenTotalSupply @entity(immutable: false) {
  id: ID!           # token_address + "-totalsupply"
  token: TokenCore!
  value: BigInt!
}

type Pool @entity(immutable: false) {
  id: ID!
  address: Bytes!
  token0: TokenCore!
  token1: TokenCore!
  reserve0: BigInt!
  reserve1: BigInt!
  totalSupply: BigInt!
  fee: BigInt!
  createdAt: BigInt!
  createdAtBlock: BigInt!
}

type User @entity(immutable: true) {
  id: ID!
  address: Bytes!
}

type LiquidityPosition @entity(immutable: false) {
  id: ID!
  user: User!
  pool: Pool!
  liquidityTokenBalance: BigInt!
  token0Amount: BigInt!
  token1Amount: BigInt!
  createdAt: BigInt!
  updatedAt: BigInt!
}

type Swap @entity(immutable: true) {
  id: ID!
  user: User!
  pool: Pool!
  tokenIn: TokenCore!
  tokenOut: TokenCore!
  amountIn: BigInt!
  amountOut: BigInt!
  fee: BigInt!
  timestamp: BigInt!
}

type LiquidityChange @entity(immutable: true) {
  id: ID!
  user: User!
  pool: Pool!
  type: String!
  token0Amount: BigInt!
  token1Amount: BigInt!
  liquidityAmount: BigInt!
  timestamp: BigInt!
}

